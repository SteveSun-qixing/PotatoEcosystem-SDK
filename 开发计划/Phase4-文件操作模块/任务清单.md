# Phase4 - 文件操作模块

**状态**: 待开始  
**预计时间**: 3-4 天  
**依赖**: Phase2, Phase3

---

## 1. 阶段目标

- 实现 FileAPI 文件操作 API
- 实现 ZIP 文件解析和打包
- 实现 YAML 配置解析
- 实现文件验证机制
- 实现文件缓存系统

---

## 2. 任务清单

### 2.1 文件类型定义

#### 任务 4.1.1: 定义文件操作类型
**优先级**: P0  
**描述**: 创建 `src/api/file-types.ts`

```typescript
import { ChipsId, Timestamp } from '../types/base';

/**
 * 文件信息
 */
export interface FileInfo {
  path: string;
  name: string;
  extension: string;
  size: number;
  modified: Timestamp;
  type: 'card' | 'box' | 'resource' | 'unknown';
}

/**
 * 文件加载选项
 */
export interface LoadOptions {
  /** 是否使用缓存 */
  cache?: boolean;
  /** 是否验证文件完整性 */
  verify?: boolean;
  /** 是否加载资源文件 */
  loadResources?: boolean;
  /** 最大资源加载数量 */
  maxResourceCount?: number;
}

/**
 * 文件保存选项
 */
export interface SaveOptions {
  /** 是否覆盖现有文件 */
  overwrite?: boolean;
  /** 是否压缩（.card/.box 文件为零压缩） */
  compress?: boolean;
  /** 是否验证保存后的文件 */
  verify?: boolean;
  /** 备份原文件 */
  backup?: boolean;
}

/**
 * 文件验证选项
 */
export interface ValidateOptions {
  /** 验证结构完整性 */
  structure?: boolean;
  /** 验证资源完整性 */
  resources?: boolean;
  /** 验证元数据 */
  metadata?: boolean;
}

/**
 * 文件验证结果
 */
export interface FileValidationResult {
  valid: boolean;
  fileType: 'card' | 'box' | 'unknown';
  errors: ValidationIssue[];
  warnings: ValidationIssue[];
}

/**
 * 验证问题
 */
export interface ValidationIssue {
  code: string;
  message: string;
  path?: string;
  severity: 'error' | 'warning';
}

/**
 * ZIP 文件条目
 */
export interface ZipEntry {
  name: string;
  size: number;
  compressedSize: number;
  isDirectory: boolean;
  content?: ArrayBuffer;
}

/**
 * 原始文件数据
 */
export interface RawFileData {
  metadata?: string;
  structure?: string;
  content?: string;
  cover?: string;
  resources: Map<string, ArrayBuffer>;
}
```

**验收标准**:
- [ ] 类型定义完整
- [ ] 符合文件格式规范

---

### 2.2 FileAPI 实现

#### 任务 4.2.1: 实现 FileAPI 类
**优先级**: P0  
**描述**: 创建 `src/api/file-api.ts`

```typescript
import { CoreConnector, FileError, ErrorCodes } from '../core';
import { Logger } from '../logger';
import { ConfigManager } from '../config';
import { Card, CardMetadata, CardStructure } from '../types/card';
import { Box, BoxMetadata, BoxStructure, BoxContent } from '../types/box';
import {
  FileInfo,
  LoadOptions,
  SaveOptions,
  ValidateOptions,
  FileValidationResult,
  RawFileData,
} from './file-types';
import { isCardFile, isBoxFile, isSafePath, getFileName, getExtension } from '../utils/path';
import { validateCardMetadata, validateBoxMetadata } from '../utils/validation';

/**
 * 默认加载选项
 */
const DEFAULT_LOAD_OPTIONS: Required<LoadOptions> = {
  cache: true,
  verify: true,
  loadResources: true,
  maxResourceCount: 1000,
};

/**
 * 默认保存选项
 */
const DEFAULT_SAVE_OPTIONS: Required<SaveOptions> = {
  overwrite: false,
  compress: false,
  verify: true,
  backup: true,
};

/**
 * 文件操作 API
 */
export class FileAPI {
  private _connector: CoreConnector;
  private _logger: Logger;
  private _config: ConfigManager;
  private _cache = new Map<string, Card | Box>();
  private _cacheMaxSize = 100;

  constructor(connector: CoreConnector, logger: Logger, config: ConfigManager) {
    this._connector = connector;
    this._logger = logger.createChild('FileAPI');
    this._config = config;
    this._cacheMaxSize = config.get('cache.maxSize', 100);
  }

  /**
   * 加载卡片文件
   */
  async loadCard(path: string, options?: LoadOptions): Promise<Card> {
    const opts = { ...DEFAULT_LOAD_OPTIONS, ...options };
    
    this._logger.debug('Loading card', { path, options: opts });
    
    // 验证路径
    if (!isSafePath(path)) {
      throw new FileError(ErrorCodes.FILE_INVALID_PATH, 'Invalid file path', { path });
    }
    
    if (!isCardFile(path)) {
      throw new FileError(ErrorCodes.FILE_FORMAT_INVALID, 'Not a card file', { path });
    }

    // 检查缓存
    if (opts.cache && this._cache.has(path)) {
      this._logger.debug('Card loaded from cache', { path });
      return this._cache.get(path) as Card;
    }

    // 通过 Core 加载文件
    const response = await this._connector.request<RawFileData>({
      service: 'file',
      method: 'read',
      payload: {
        path,
        loadResources: opts.loadResources,
        maxResourceCount: opts.maxResourceCount,
      },
      timeout: this._config.get('timeout.file', 60000),
    });

    if (!response.success || !response.data) {
      throw new FileError(ErrorCodes.FILE_READ_FAILED, response.error || 'Failed to load card', { path });
    }

    // 解析卡片数据
    const card = await this._parseCard(response.data, path);

    // 验证
    if (opts.verify) {
      const validation = await this.validateCard(path, card);
      if (!validation.valid) {
        throw new FileError(ErrorCodes.FILE_CORRUPTED, 'Card validation failed', {
          path,
          errors: validation.errors,
        });
      }
    }

    // 缓存
    if (opts.cache) {
      this._addToCache(path, card);
    }

    this._logger.info('Card loaded successfully', { path, id: card.id });
    return card;
  }

  /**
   * 保存卡片文件
   */
  async saveCard(path: string, card: Card, options?: SaveOptions): Promise<void> {
    const opts = { ...DEFAULT_SAVE_OPTIONS, ...options };
    
    this._logger.debug('Saving card', { path, id: card.id, options: opts });
    
    // 验证路径
    if (!isSafePath(path)) {
      throw new FileError(ErrorCodes.FILE_INVALID_PATH, 'Invalid file path', { path });
    }

    // 检查文件是否存在
    if (!opts.overwrite) {
      const exists = await this._checkFileExists(path);
      if (exists) {
        throw new FileError(ErrorCodes.FILE_WRITE_FAILED, 'File already exists', { path });
      }
    }

    // 序列化卡片数据
    const rawData = this._serializeCard(card);

    // 通过 Core 保存文件
    const response = await this._connector.request({
      service: 'file',
      method: 'write',
      payload: {
        path,
        data: rawData,
        backup: opts.backup,
        compress: opts.compress,
      },
      timeout: this._config.get('timeout.file', 60000),
    });

    if (!response.success) {
      throw new FileError(ErrorCodes.FILE_WRITE_FAILED, response.error || 'Failed to save card', { path });
    }

    // 验证保存结果
    if (opts.verify) {
      const validation = await this.validateFile(path);
      if (!validation.valid) {
        throw new FileError(ErrorCodes.FILE_CORRUPTED, 'Saved file validation failed', {
          path,
          errors: validation.errors,
        });
      }
    }

    // 更新缓存
    this._addToCache(path, card);

    this._logger.info('Card saved successfully', { path, id: card.id });
  }

  /**
   * 加载箱子文件
   */
  async loadBox(path: string, options?: LoadOptions): Promise<Box> {
    const opts = { ...DEFAULT_LOAD_OPTIONS, ...options };
    
    this._logger.debug('Loading box', { path, options: opts });
    
    // 验证路径
    if (!isSafePath(path)) {
      throw new FileError(ErrorCodes.FILE_INVALID_PATH, 'Invalid file path', { path });
    }
    
    if (!isBoxFile(path)) {
      throw new FileError(ErrorCodes.FILE_FORMAT_INVALID, 'Not a box file', { path });
    }

    // 检查缓存
    if (opts.cache && this._cache.has(path)) {
      this._logger.debug('Box loaded from cache', { path });
      return this._cache.get(path) as Box;
    }

    // 通过 Core 加载文件
    const response = await this._connector.request<RawFileData>({
      service: 'file',
      method: 'read',
      payload: { path },
      timeout: this._config.get('timeout.file', 60000),
    });

    if (!response.success || !response.data) {
      throw new FileError(ErrorCodes.FILE_READ_FAILED, response.error || 'Failed to load box', { path });
    }

    // 解析箱子数据
    const box = await this._parseBox(response.data, path);

    // 验证
    if (opts.verify) {
      const validation = await this.validateBox(path, box);
      if (!validation.valid) {
        throw new FileError(ErrorCodes.FILE_CORRUPTED, 'Box validation failed', {
          path,
          errors: validation.errors,
        });
      }
    }

    // 缓存
    if (opts.cache) {
      this._addToCache(path, box);
    }

    this._logger.info('Box loaded successfully', { path, id: box.id });
    return box;
  }

  /**
   * 保存箱子文件
   */
  async saveBox(path: string, box: Box, options?: SaveOptions): Promise<void> {
    const opts = { ...DEFAULT_SAVE_OPTIONS, ...options };
    
    this._logger.debug('Saving box', { path, id: box.id, options: opts });
    
    // 验证路径
    if (!isSafePath(path)) {
      throw new FileError(ErrorCodes.FILE_INVALID_PATH, 'Invalid file path', { path });
    }

    // 检查文件是否存在
    if (!opts.overwrite) {
      const exists = await this._checkFileExists(path);
      if (exists) {
        throw new FileError(ErrorCodes.FILE_WRITE_FAILED, 'File already exists', { path });
      }
    }

    // 序列化箱子数据
    const rawData = this._serializeBox(box);

    // 通过 Core 保存文件
    const response = await this._connector.request({
      service: 'file',
      method: 'write',
      payload: {
        path,
        data: rawData,
        backup: opts.backup,
        compress: opts.compress,
      },
      timeout: this._config.get('timeout.file', 60000),
    });

    if (!response.success) {
      throw new FileError(ErrorCodes.FILE_WRITE_FAILED, response.error || 'Failed to save box', { path });
    }

    // 更新缓存
    this._addToCache(path, box);

    this._logger.info('Box saved successfully', { path, id: box.id });
  }

  /**
   * 验证文件
   */
  async validateFile(path: string, options?: ValidateOptions): Promise<FileValidationResult> {
    this._logger.debug('Validating file', { path });

    const response = await this._connector.request<FileValidationResult>({
      service: 'file',
      method: 'validate',
      payload: { path, options },
    });

    if (!response.success) {
      return {
        valid: false,
        fileType: 'unknown',
        errors: [{ code: 'VAL-1001', message: response.error || 'Validation failed', severity: 'error' }],
        warnings: [],
      };
    }

    return response.data!;
  }

  /**
   * 验证卡片
   */
  async validateCard(path: string, card: Card): Promise<FileValidationResult> {
    const errors: ValidationIssue[] = [];
    const warnings: ValidationIssue[] = [];

    // 验证元数据
    if (!validateCardMetadata(card.metadata)) {
      errors.push({
        code: 'VAL-CARD-001',
        message: 'Invalid card metadata',
        path: 'metadata',
        severity: 'error',
      });
    }

    // 验证 ID 一致性
    if (card.id !== card.metadata.card_id) {
      errors.push({
        code: 'VAL-CARD-002',
        message: 'Card ID mismatch',
        path: 'id',
        severity: 'error',
      });
    }

    return {
      valid: errors.length === 0,
      fileType: 'card',
      errors,
      warnings,
    };
  }

  /**
   * 验证箱子
   */
  async validateBox(path: string, box: Box): Promise<FileValidationResult> {
    const errors: ValidationIssue[] = [];
    const warnings: ValidationIssue[] = [];

    // 验证元数据
    if (!validateBoxMetadata(box.metadata)) {
      errors.push({
        code: 'VAL-BOX-001',
        message: 'Invalid box metadata',
        path: 'metadata',
        severity: 'error',
      });
    }

    // 验证 ID 一致性
    if (box.id !== box.metadata.box_id) {
      errors.push({
        code: 'VAL-BOX-002',
        message: 'Box ID mismatch',
        path: 'id',
        severity: 'error',
      });
    }

    return {
      valid: errors.length === 0,
      fileType: 'box',
      errors,
      warnings,
    };
  }

  /**
   * 获取文件信息
   */
  async getFileInfo(path: string): Promise<FileInfo> {
    const response = await this._connector.request<FileInfo>({
      service: 'file',
      method: 'info',
      payload: { path },
    });

    if (!response.success || !response.data) {
      throw new FileError(ErrorCodes.FILE_NOT_FOUND, 'File not found', { path });
    }

    return response.data;
  }

  /**
   * 检查文件是否存在
   */
  async exists(path: string): Promise<boolean> {
    return this._checkFileExists(path);
  }

  /**
   * 复制文件
   */
  async copy(sourcePath: string, destPath: string, overwrite = false): Promise<void> {
    const response = await this._connector.request({
      service: 'file',
      method: 'copy',
      payload: { sourcePath, destPath, overwrite },
    });

    if (!response.success) {
      throw new FileError(ErrorCodes.FILE_WRITE_FAILED, response.error || 'Copy failed', {
        sourcePath,
        destPath,
      });
    }
  }

  /**
   * 移动文件
   */
  async move(sourcePath: string, destPath: string, overwrite = false): Promise<void> {
    const response = await this._connector.request({
      service: 'file',
      method: 'move',
      payload: { sourcePath, destPath, overwrite },
    });

    if (!response.success) {
      throw new FileError(ErrorCodes.FILE_WRITE_FAILED, response.error || 'Move failed', {
        sourcePath,
        destPath,
      });
    }

    // 更新缓存
    if (this._cache.has(sourcePath)) {
      const cached = this._cache.get(sourcePath);
      this._cache.delete(sourcePath);
      if (cached) {
        this._cache.set(destPath, cached);
      }
    }
  }

  /**
   * 删除文件
   */
  async delete(path: string): Promise<void> {
    const response = await this._connector.request({
      service: 'file',
      method: 'delete',
      payload: { path },
    });

    if (!response.success) {
      throw new FileError(ErrorCodes.FILE_WRITE_FAILED, response.error || 'Delete failed', { path });
    }

    // 清除缓存
    this._cache.delete(path);
  }

  /**
   * 清除缓存
   */
  clearCache(): void {
    this._cache.clear();
    this._logger.debug('File cache cleared');
  }

  /**
   * 从缓存中移除
   */
  removeFromCache(path: string): void {
    this._cache.delete(path);
  }

  /**
   * 检查文件是否存在
   */
  private async _checkFileExists(path: string): Promise<boolean> {
    const response = await this._connector.request<boolean>({
      service: 'file',
      method: 'exists',
      payload: { path },
    });
    return response.success && response.data === true;
  }

  /**
   * 解析卡片数据
   */
  private async _parseCard(data: RawFileData, path: string): Promise<Card> {
    // 通过 Core 解析 YAML
    const metadataResponse = await this._connector.request<CardMetadata>({
      service: 'parser',
      method: 'parseYaml',
      payload: { content: data.metadata },
    });

    if (!metadataResponse.success || !metadataResponse.data) {
      throw new FileError(ErrorCodes.FILE_FORMAT_INVALID, 'Failed to parse card metadata', { path });
    }

    const structureResponse = await this._connector.request<CardStructure>({
      service: 'parser',
      method: 'parseYaml',
      payload: { content: data.structure },
    });

    const metadata = metadataResponse.data;
    const structure = structureResponse.data || { structure: [], manifest: { card_count: 0, resource_count: 0, resources: [] } };

    return {
      id: metadata.card_id,
      metadata,
      structure,
      resources: data.resources,
    };
  }

  /**
   * 解析箱子数据
   */
  private async _parseBox(data: RawFileData, path: string): Promise<Box> {
    const metadataResponse = await this._connector.request<BoxMetadata>({
      service: 'parser',
      method: 'parseYaml',
      payload: { content: data.metadata },
    });

    if (!metadataResponse.success || !metadataResponse.data) {
      throw new FileError(ErrorCodes.FILE_FORMAT_INVALID, 'Failed to parse box metadata', { path });
    }

    const structureResponse = await this._connector.request<BoxStructure>({
      service: 'parser',
      method: 'parseYaml',
      payload: { content: data.structure },
    });

    const contentResponse = await this._connector.request<BoxContent>({
      service: 'parser',
      method: 'parseYaml',
      payload: { content: data.content },
    });

    const metadata = metadataResponse.data;
    const structure = structureResponse.data || { cards: [] };
    const content = contentResponse.data || { active_layout: 'grid', layout_configs: {} };

    return {
      id: metadata.box_id,
      metadata,
      structure,
      content,
    };
  }

  /**
   * 序列化卡片数据
   */
  private _serializeCard(card: Card): RawFileData {
    return {
      metadata: JSON.stringify(card.metadata),
      structure: JSON.stringify(card.structure),
      resources: card.resources,
    };
  }

  /**
   * 序列化箱子数据
   */
  private _serializeBox(box: Box): RawFileData {
    return {
      metadata: JSON.stringify(box.metadata),
      structure: JSON.stringify(box.structure),
      content: JSON.stringify(box.content),
      resources: new Map(),
    };
  }

  /**
   * 添加到缓存
   */
  private _addToCache(path: string, item: Card | Box): void {
    // LRU 策略
    if (this._cache.size >= this._cacheMaxSize) {
      const firstKey = this._cache.keys().next().value;
      if (firstKey) {
        this._cache.delete(firstKey);
      }
    }
    this._cache.set(path, item);
  }
}
```

**验收标准**:
- [ ] 卡片加载/保存正常
- [ ] 箱子加载/保存正常
- [ ] 文件验证功能完整
- [ ] 缓存机制有效

---

### 2.3 单元测试

#### 任务 4.3.1: 创建 FileAPI 单元测试
**优先级**: P0  
**描述**: 创建 `tests/unit/api/file-api.test.ts`

**测试用例**:
1. 加载卡片文件
2. 保存卡片文件
3. 加载箱子文件
4. 保存箱子文件
5. 文件验证
6. 文件复制/移动/删除
7. 缓存机制
8. 错误处理

**验收标准**:
- [ ] 所有测试用例通过
- [ ] 覆盖率 ≥ 85%

---

## 3. 验收标准

### 3.1 功能验收

- [ ] 卡片文件加载正常
- [ ] 卡片文件保存正常
- [ ] 箱子文件加载正常
- [ ] 箱子文件保存正常
- [ ] 文件验证功能完整
- [ ] 缓存机制有效
- [ ] 错误处理完善

### 3.2 性能要求

- [ ] 1MB 以下文件加载 < 100ms
- [ ] 1-10MB 文件加载 < 500ms
- [ ] 缓存命中率 > 80%

### 3.3 代码质量

- [ ] 测试覆盖率 ≥ 85%
- [ ] 所有方法有 JSDoc 注释

---

## 4. 注意事项

1. **文件格式**: 严格遵循 .card/.box 文件格式规范
2. **零压缩**: .card/.box 文件必须使用零压缩存储
3. **路径安全**: 防止路径遍历攻击
4. **缓存策略**: 使用 LRU 策略管理缓存
5. **资源限制**: 大文件分块加载

---

**状态更新日期**: 2026-02-01
