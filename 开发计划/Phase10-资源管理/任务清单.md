# Phase10 - 资源管理

**状态**: 待开始  
**预计时间**: 2-3 天  
**依赖**: Phase4

---

## 1. 阶段目标

- 实现 ResourceManager 资源管理系统
- 实现资源加载和缓存
- 支持多协议资源访问（chips://, file://, http://）
- 实现资源路径解析

---

## 2. 任务清单

### 2.1 资源类型定义

#### 任务 10.1.1: 定义资源类型
**优先级**: P0  
**描述**: 创建 `src/resource/types.ts`

```typescript
/**
 * 资源协议
 */
export type ResourceProtocol = 'chips' | 'file' | 'http' | 'https' | 'data';

/**
 * 资源类型
 */
export type ResourceType = 'image' | 'audio' | 'video' | 'font' | 'style' | 'script' | 'json' | 'text' | 'binary';

/**
 * 资源信息
 */
export interface Resource {
  uri: string;
  protocol: ResourceProtocol;
  path: string;
  type: ResourceType;
  size?: number;
  mimeType?: string;
  data?: ArrayBuffer | Blob | string;
  metadata?: Record<string, unknown>;
}

/**
 * 资源加载选项
 */
export interface LoadResourceOptions {
  cache?: boolean;
  timeout?: number;
  responseType?: 'arraybuffer' | 'blob' | 'text' | 'json';
  headers?: Record<string, string>;
}

/**
 * 资源缓存条目
 */
export interface CacheEntry {
  resource: Resource;
  loadedAt: string;
  accessedAt: string;
  accessCount: number;
  size: number;
}

/**
 * 资源缓存配置
 */
export interface CacheConfig {
  maxSize?: number;
  maxEntries?: number;
  ttl?: number;
}

/**
 * 资源 URI 解析结果
 */
export interface ParsedUri {
  protocol: ResourceProtocol;
  host?: string;
  port?: number;
  path: string;
  query?: Record<string, string>;
  fragment?: string;
}

/**
 * 资源预加载配置
 */
export interface PreloadConfig {
  resources: string[];
  priority?: 'high' | 'normal' | 'low';
  concurrent?: number;
}
```

**验收标准**:
- [ ] 类型定义完整
- [ ] 支持多种资源类型

---

### 2.2 ResourceManager 实现

#### 任务 10.2.1: 实现 ResourceManager 类
**优先级**: P0  
**描述**: 创建 `src/resource/manager.ts`

```typescript
import { CoreConnector, ChipsError, ErrorCodes } from '../core';
import { Logger } from '../logger';
import { ConfigManager } from '../config';
import { EventBus } from '../event';
import {
  Resource,
  ResourceProtocol,
  ResourceType,
  LoadResourceOptions,
  CacheEntry,
  CacheConfig,
  ParsedUri,
  PreloadConfig,
} from './types';
import { withTimeout } from '../utils/async';

/**
 * MIME 类型映射
 */
const MIME_TYPE_MAP: Record<string, ResourceType> = {
  'image/png': 'image',
  'image/jpeg': 'image',
  'image/gif': 'image',
  'image/webp': 'image',
  'image/svg+xml': 'image',
  'audio/mpeg': 'audio',
  'audio/wav': 'audio',
  'audio/ogg': 'audio',
  'video/mp4': 'video',
  'video/webm': 'video',
  'font/woff': 'font',
  'font/woff2': 'font',
  'text/css': 'style',
  'application/javascript': 'script',
  'application/json': 'json',
  'text/plain': 'text',
  'text/html': 'text',
};

/**
 * 扩展名类型映射
 */
const EXTENSION_TYPE_MAP: Record<string, ResourceType> = {
  png: 'image',
  jpg: 'image',
  jpeg: 'image',
  gif: 'image',
  webp: 'image',
  svg: 'image',
  mp3: 'audio',
  wav: 'audio',
  ogg: 'audio',
  mp4: 'video',
  webm: 'video',
  woff: 'font',
  woff2: 'font',
  ttf: 'font',
  css: 'style',
  js: 'script',
  json: 'json',
  txt: 'text',
  html: 'text',
};

/**
 * 默认缓存配置
 */
const DEFAULT_CACHE_CONFIG: Required<CacheConfig> = {
  maxSize: 100 * 1024 * 1024, // 100MB
  maxEntries: 500,
  ttl: 3600000, // 1 小时
};

/**
 * 资源管理器
 */
export class ResourceManager {
  private _connector: CoreConnector;
  private _logger: Logger;
  private _config: ConfigManager;
  private _eventBus: EventBus;
  private _cache = new Map<string, CacheEntry>();
  private _cacheConfig: Required<CacheConfig>;
  private _totalCacheSize = 0;

  constructor(
    connector: CoreConnector,
    logger: Logger,
    config: ConfigManager,
    eventBus: EventBus
  ) {
    this._connector = connector;
    this._logger = logger.createChild('ResourceManager');
    this._config = config;
    this._eventBus = eventBus;
    this._cacheConfig = { ...DEFAULT_CACHE_CONFIG };
  }

  /**
   * 加载资源
   */
  async load(uri: string, options?: LoadResourceOptions): Promise<Resource> {
    const opts: Required<LoadResourceOptions> = {
      cache: true,
      timeout: 30000,
      responseType: 'arraybuffer',
      headers: {},
      ...options,
    };

    this._logger.debug('Loading resource', { uri, options: opts });

    // 检查缓存
    if (opts.cache && this._cache.has(uri)) {
      const entry = this._cache.get(uri)!;
      entry.accessedAt = new Date().toISOString();
      entry.accessCount++;
      
      this._logger.debug('Resource loaded from cache', { uri });
      return entry.resource;
    }

    // 解析 URI
    const parsed = this.parseUri(uri);
    
    // 根据协议加载
    let resource: Resource;
    try {
      switch (parsed.protocol) {
        case 'chips':
          resource = await this._loadChipsResource(parsed, opts);
          break;
        case 'file':
          resource = await this._loadFileResource(parsed, opts);
          break;
        case 'http':
        case 'https':
          resource = await this._loadHttpResource(uri, opts);
          break;
        case 'data':
          resource = this._loadDataResource(uri);
          break;
        default:
          throw new ChipsError(ErrorCodes.RES_INVALID_URI, `Unsupported protocol: ${parsed.protocol}`);
      }
    } catch (error) {
      const err = error instanceof ChipsError ? error : new ChipsError(
        ErrorCodes.RES_LOAD_FAILED,
        `Failed to load resource: ${uri}`,
        { error: String(error) }
      );
      
      this._logger.error('Resource load failed', { uri, error: err });
      throw err;
    }

    // 添加到缓存
    if (opts.cache && resource.data) {
      this._addToCache(uri, resource);
    }

    // 发布事件
    await this._eventBus.emit('resource:loaded', { uri, resource });

    this._logger.info('Resource loaded', { uri, type: resource.type, size: resource.size });
    return resource;
  }

  /**
   * 预加载资源
   */
  async preload(config: PreloadConfig): Promise<void> {
    const { resources, concurrent = 4 } = config;
    
    this._logger.debug('Preloading resources', { count: resources.length });

    const chunks: string[][] = [];
    for (let i = 0; i < resources.length; i += concurrent) {
      chunks.push(resources.slice(i, i + concurrent));
    }

    for (const chunk of chunks) {
      await Promise.all(
        chunk.map((uri) =>
          this.load(uri, { cache: true }).catch((error) => {
            this._logger.warn('Preload failed', { uri, error });
          })
        )
      );
    }

    this._logger.info('Preload complete', { count: resources.length });
  }

  /**
   * 检查资源是否存在
   */
  async exists(uri: string): Promise<boolean> {
    const parsed = this.parseUri(uri);
    
    try {
      switch (parsed.protocol) {
        case 'chips':
        case 'file':
          const response = await this._connector.request<boolean>({
            service: 'resource',
            method: 'exists',
            payload: { uri },
          });
          return response.success && response.data === true;
        case 'http':
        case 'https':
          const headResponse = await fetch(uri, { method: 'HEAD' });
          return headResponse.ok;
        default:
          return false;
      }
    } catch {
      return false;
    }
  }

  /**
   * 解析 URI
   */
  parseUri(uri: string): ParsedUri {
    const protocolMatch = uri.match(/^(\w+):\/\//);
    const protocol = (protocolMatch?.[1] || 'file') as ResourceProtocol;
    
    let path = uri;
    let host: string | undefined;
    let port: number | undefined;
    let query: Record<string, string> | undefined;
    let fragment: string | undefined;

    // 移除协议前缀
    if (protocolMatch) {
      path = uri.slice(protocolMatch[0].length);
    }

    // 解析 fragment
    const fragmentIndex = path.indexOf('#');
    if (fragmentIndex !== -1) {
      fragment = path.slice(fragmentIndex + 1);
      path = path.slice(0, fragmentIndex);
    }

    // 解析 query
    const queryIndex = path.indexOf('?');
    if (queryIndex !== -1) {
      const queryString = path.slice(queryIndex + 1);
      path = path.slice(0, queryIndex);
      query = {};
      for (const pair of queryString.split('&')) {
        const [key, value] = pair.split('=');
        if (key) {
          query[decodeURIComponent(key)] = decodeURIComponent(value || '');
        }
      }
    }

    // 解析 host 和 port（对于 http/https）
    if (protocol === 'http' || protocol === 'https') {
      const hostMatch = path.match(/^([^:/]+)(?::(\d+))?(\/.*)?$/);
      if (hostMatch) {
        host = hostMatch[1];
        port = hostMatch[2] ? parseInt(hostMatch[2], 10) : undefined;
        path = hostMatch[3] || '/';
      }
    }

    return { protocol, host, port, path, query, fragment };
  }

  /**
   * 构建 URI
   */
  buildUri(parsed: ParsedUri): string {
    let uri = `${parsed.protocol}://`;
    
    if (parsed.host) {
      uri += parsed.host;
      if (parsed.port) {
        uri += `:${parsed.port}`;
      }
    }
    
    uri += parsed.path;
    
    if (parsed.query && Object.keys(parsed.query).length > 0) {
      const queryString = Object.entries(parsed.query)
        .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
        .join('&');
      uri += `?${queryString}`;
    }
    
    if (parsed.fragment) {
      uri += `#${parsed.fragment}`;
    }
    
    return uri;
  }

  /**
   * 获取资源类型
   */
  getResourceType(uri: string, mimeType?: string): ResourceType {
    // 优先使用 MIME 类型
    if (mimeType && MIME_TYPE_MAP[mimeType]) {
      return MIME_TYPE_MAP[mimeType];
    }

    // 使用扩展名推断
    const extension = uri.split('.').pop()?.toLowerCase();
    if (extension && EXTENSION_TYPE_MAP[extension]) {
      return EXTENSION_TYPE_MAP[extension];
    }

    return 'binary';
  }

  /**
   * 从缓存获取资源
   */
  getFromCache(uri: string): Resource | undefined {
    return this._cache.get(uri)?.resource;
  }

  /**
   * 检查是否在缓存中
   */
  isInCache(uri: string): boolean {
    return this._cache.has(uri);
  }

  /**
   * 从缓存移除
   */
  removeFromCache(uri: string): boolean {
    const entry = this._cache.get(uri);
    if (entry) {
      this._totalCacheSize -= entry.size;
      this._cache.delete(uri);
      return true;
    }
    return false;
  }

  /**
   * 清除缓存
   */
  clearCache(): void {
    this._cache.clear();
    this._totalCacheSize = 0;
    this._logger.info('Cache cleared');
  }

  /**
   * 获取缓存统计
   */
  getCacheStats(): { size: number; entries: number; maxSize: number; maxEntries: number } {
    return {
      size: this._totalCacheSize,
      entries: this._cache.size,
      maxSize: this._cacheConfig.maxSize,
      maxEntries: this._cacheConfig.maxEntries,
    };
  }

  /**
   * 设置缓存配置
   */
  setCacheConfig(config: Partial<CacheConfig>): void {
    this._cacheConfig = { ...this._cacheConfig, ...config };
  }

  // ========== 私有方法 ==========

  /**
   * 加载 Chips 协议资源
   */
  private async _loadChipsResource(parsed: ParsedUri, opts: Required<LoadResourceOptions>): Promise<Resource> {
    const response = await withTimeout(
      this._connector.request<{ data: ArrayBuffer; mimeType: string; size: number }>({
        service: 'resource',
        method: 'read',
        payload: { path: parsed.path },
      }),
      opts.timeout
    );

    if (!response.success || !response.data) {
      throw new ChipsError(ErrorCodes.RES_NOT_FOUND, `Resource not found: ${parsed.path}`);
    }

    return {
      uri: this.buildUri(parsed),
      protocol: 'chips',
      path: parsed.path,
      type: this.getResourceType(parsed.path, response.data.mimeType),
      size: response.data.size,
      mimeType: response.data.mimeType,
      data: response.data.data,
    };
  }

  /**
   * 加载文件资源
   */
  private async _loadFileResource(parsed: ParsedUri, opts: Required<LoadResourceOptions>): Promise<Resource> {
    const response = await withTimeout(
      this._connector.request<{ data: ArrayBuffer; mimeType: string; size: number }>({
        service: 'file',
        method: 'readBinary',
        payload: { path: parsed.path },
      }),
      opts.timeout
    );

    if (!response.success || !response.data) {
      throw new ChipsError(ErrorCodes.RES_NOT_FOUND, `File not found: ${parsed.path}`);
    }

    return {
      uri: this.buildUri(parsed),
      protocol: 'file',
      path: parsed.path,
      type: this.getResourceType(parsed.path, response.data.mimeType),
      size: response.data.size,
      mimeType: response.data.mimeType,
      data: response.data.data,
    };
  }

  /**
   * 加载 HTTP 资源
   */
  private async _loadHttpResource(uri: string, opts: Required<LoadResourceOptions>): Promise<Resource> {
    const response = await withTimeout(
      fetch(uri, { headers: opts.headers }),
      opts.timeout
    );

    if (!response.ok) {
      throw new ChipsError(ErrorCodes.RES_LOAD_FAILED, `HTTP error: ${response.status}`);
    }

    const mimeType = response.headers.get('content-type') || undefined;
    const data = await response.arrayBuffer();

    const parsed = this.parseUri(uri);

    return {
      uri,
      protocol: parsed.protocol as ResourceProtocol,
      path: parsed.path,
      type: this.getResourceType(uri, mimeType),
      size: data.byteLength,
      mimeType,
      data,
    };
  }

  /**
   * 加载 Data URI 资源
   */
  private _loadDataResource(uri: string): Resource {
    const match = uri.match(/^data:([^;,]+)?(?:;base64)?,(.*)$/);
    if (!match) {
      throw new ChipsError(ErrorCodes.RES_INVALID_URI, 'Invalid data URI');
    }

    const mimeType = match[1] || 'text/plain';
    const isBase64 = uri.includes(';base64,');
    const content = match[2];

    let data: ArrayBuffer;
    if (isBase64) {
      const binary = atob(content);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      data = bytes.buffer;
    } else {
      const encoder = new TextEncoder();
      data = encoder.encode(decodeURIComponent(content)).buffer;
    }

    return {
      uri,
      protocol: 'data',
      path: '',
      type: this.getResourceType('', mimeType),
      size: data.byteLength,
      mimeType,
      data,
    };
  }

  /**
   * 添加到缓存
   */
  private _addToCache(uri: string, resource: Resource): void {
    const size = resource.data instanceof ArrayBuffer 
      ? resource.data.byteLength 
      : typeof resource.data === 'string' 
        ? resource.data.length 
        : 0;

    // 检查是否需要清理缓存
    while (
      this._totalCacheSize + size > this._cacheConfig.maxSize ||
      this._cache.size >= this._cacheConfig.maxEntries
    ) {
      this._evictOldest();
    }

    const entry: CacheEntry = {
      resource,
      loadedAt: new Date().toISOString(),
      accessedAt: new Date().toISOString(),
      accessCount: 1,
      size,
    };

    this._cache.set(uri, entry);
    this._totalCacheSize += size;
  }

  /**
   * 移除最老的缓存条目
   */
  private _evictOldest(): void {
    let oldest: string | null = null;
    let oldestTime = Infinity;

    for (const [uri, entry] of this._cache) {
      const time = new Date(entry.accessedAt).getTime();
      if (time < oldestTime) {
        oldestTime = time;
        oldest = uri;
      }
    }

    if (oldest) {
      this.removeFromCache(oldest);
    }
  }
}
```

**验收标准**:
- [ ] 资源加载正常
- [ ] 多协议支持
- [ ] 缓存管理正常
- [ ] URI 解析正确

---

### 2.3 单元测试

#### 任务 10.3.1: 创建 ResourceManager 单元测试
**优先级**: P0  
**描述**: 创建 `tests/unit/resource/manager.test.ts`

**测试用例**:
1. 资源加载
2. URI 解析
3. 缓存管理
4. 预加载
5. 类型推断
6. 错误处理

**验收标准**:
- [ ] 所有测试用例通过
- [ ] 覆盖率 ≥ 85%

---

## 3. 验收标准

### 3.1 功能验收

- [ ] 资源加载正常
- [ ] 多协议支持完整
- [ ] 缓存管理有效
- [ ] URI 解析正确
- [ ] 预加载功能正常

### 3.2 性能要求

- [ ] 缓存命中时加载 < 1ms
- [ ] 本地资源加载 < 50ms
- [ ] 缓存 LRU 策略有效

### 3.3 代码质量

- [ ] 测试覆盖率 ≥ 85%
- [ ] 所有方法有 JSDoc 注释

---

## 4. 注意事项

1. **协议安全**: 限制可访问的协议
2. **缓存策略**: 使用 LRU 算法
3. **内存限制**: 大资源不缓存
4. **超时处理**: 所有网络请求有超时

---

**状态更新日期**: 2026-02-01
