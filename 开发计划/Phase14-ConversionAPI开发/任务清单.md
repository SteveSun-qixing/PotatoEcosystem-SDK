# Phase14 - ConversionAPI 开发

**状态**: 待开始  
**预计时间**: 3-4 天  
**依赖**: Phase2, Phase3, Phase11

---

## 1. 阶段目标

- 实现 ConversionAPI 文件格式转换 API
- 实现 convert 方法（单文件转换）
- 实现 convertBatch 方法（批量转换）
- 实现转换器注册和管理机制
- 实现进度回调机制
- 与公共基础层 file-converter 模块集成

---

## 2. 任务清单

### 2.1 转换类型定义

#### 任务 14.1.1: 定义转换操作类型
**优先级**: P0  
**描述**: 创建 `src/api/conversion-types.ts`

```typescript
import { ChipsId } from '../types/base';

/**
 * 支持的转换目标格式
 */
export type ConversionFormat = 'html' | 'pdf' | 'png' | 'jpeg' | 'webp';

/**
 * 转换源类型
 */
export type ConversionSource = 'card' | 'box';

/**
 * 转换请求
 */
export interface ConversionRequest {
  /** 源文件路径 */
  sourcePath: string;
  /** 源类型 */
  sourceType: ConversionSource;
  /** 目标格式 */
  targetFormat: ConversionFormat;
  /** 输出路径（可选，不指定则返回内容） */
  outputPath?: string;
  /** 转换选项 */
  options?: ConversionOptions;
}

/**
 * 转换选项
 */
export interface ConversionOptions {
  /** HTML 转换选项 */
  html?: HTMLConversionOptions;
  /** PDF 转换选项 */
  pdf?: PDFConversionOptions;
  /** 图片转换选项 */
  image?: ImageConversionOptions;
  /** 通用选项 */
  common?: CommonConversionOptions;
}

/**
 * HTML 转换选项
 */
export interface HTMLConversionOptions {
  /** 是否嵌入资源（Base64） */
  embedResources?: boolean;
  /** 是否内联样式 */
  inlineStyles?: boolean;
  /** 是否包含元数据 */
  includeMetadata?: boolean;
  /** 自定义模板路径 */
  templatePath?: string;
  /** 自定义 CSS */
  customCSS?: string;
}

/**
 * PDF 转换选项
 */
export interface PDFConversionOptions {
  /** 页面尺寸 */
  pageSize?: 'A4' | 'A3' | 'Letter' | 'Legal' | { width: number; height: number };
  /** 页面方向 */
  orientation?: 'portrait' | 'landscape';
  /** 页边距（像素） */
  margin?: { top: number; right: number; bottom: number; left: number };
  /** 是否显示页眉 */
  showHeader?: boolean;
  /** 是否显示页脚 */
  showFooter?: boolean;
  /** 页眉内容 */
  headerTemplate?: string;
  /** 页脚内容 */
  footerTemplate?: string;
  /** 缩放比例 */
  scale?: number;
  /** 打印背景 */
  printBackground?: boolean;
}

/**
 * 图片转换选项
 */
export interface ImageConversionOptions {
  /** 输出宽度 */
  width?: number;
  /** 输出高度 */
  height?: number;
  /** 图片质量（0-100，仅 JPEG） */
  quality?: number;
  /** 设备像素比 */
  deviceScaleFactor?: number;
  /** 是否全页截图 */
  fullPage?: boolean;
  /** 背景色 */
  backgroundColor?: string;
  /** 是否透明背景（仅 PNG） */
  transparent?: boolean;
}

/**
 * 通用转换选项
 */
export interface CommonConversionOptions {
  /** 超时时间（毫秒） */
  timeout?: number;
  /** 是否覆盖已存在的文件 */
  overwrite?: boolean;
  /** 临时文件目录 */
  tempDir?: string;
}

/**
 * 转换结果
 */
export interface ConversionResult {
  /** 是否成功 */
  success: boolean;
  /** 源文件路径 */
  sourcePath: string;
  /** 目标格式 */
  targetFormat: ConversionFormat;
  /** 输出路径（如果指定） */
  outputPath?: string;
  /** 输出内容（如果未指定输出路径） */
  content?: ArrayBuffer | string;
  /** 文件大小（字节） */
  fileSize?: number;
  /** 转换耗时（毫秒） */
  duration: number;
  /** 错误信息 */
  error?: string;
  /** 错误代码 */
  errorCode?: string;
}

/**
 * 批量转换请求
 */
export interface BatchConversionRequest {
  /** 转换请求列表 */
  requests: ConversionRequest[];
  /** 批量选项 */
  options?: BatchConversionOptions;
}

/**
 * 批量转换选项
 */
export interface BatchConversionOptions {
  /** 并发数量 */
  concurrency?: number;
  /** 失败后是否继续 */
  continueOnError?: boolean;
  /** 总超时时间 */
  timeout?: number;
}

/**
 * 批量转换结果
 */
export interface BatchConversionResult {
  /** 总数 */
  total: number;
  /** 成功数 */
  succeeded: number;
  /** 失败数 */
  failed: number;
  /** 各项结果 */
  results: ConversionResult[];
  /** 总耗时 */
  totalDuration: number;
}

/**
 * 转换进度信息
 */
export interface ConversionProgress {
  /** 当前进度（0-100） */
  progress: number;
  /** 当前阶段 */
  stage: 'preparing' | 'rendering' | 'converting' | 'saving' | 'completed';
  /** 阶段描述 */
  message: string;
  /** 当前处理的文件（批量转换时） */
  currentFile?: string;
  /** 已完成数量（批量转换时） */
  completedCount?: number;
  /** 总数（批量转换时） */
  totalCount?: number;
}

/**
 * 转换进度回调
 */
export type ConversionProgressCallback = (progress: ConversionProgress) => void;

/**
 * 转换器接口
 */
export interface IConverter {
  /** 转换器名称 */
  readonly name: string;
  /** 支持的目标格式 */
  readonly supportedFormats: ConversionFormat[];
  /** 执行转换 */
  convert(request: ConversionRequest, onProgress?: ConversionProgressCallback): Promise<ConversionResult>;
  /** 检查是否支持指定格式 */
  supports(format: ConversionFormat): boolean;
}

/**
 * 转换器注册信息
 */
export interface ConverterRegistration {
  /** 转换器实例 */
  converter: IConverter;
  /** 优先级（数字越大优先级越高） */
  priority: number;
}
```

**验收标准**:
- [ ] 类型定义完整
- [ ] 覆盖所有转换场景
- [ ] 选项设计灵活可扩展

---

### 2.2 ConversionAPI 实现

#### 任务 14.2.1: 实现 ConversionAPI 类
**优先级**: P0  
**描述**: 创建 `src/api/conversion-api.ts`

```typescript
import { CoreConnector, ConversionError, ErrorCodes } from '../core';
import { Logger } from '../logger';
import { ConfigManager } from '../config';
import { EventBus } from '../event';
import {
  ConversionFormat,
  ConversionRequest,
  ConversionResult,
  ConversionOptions,
  BatchConversionRequest,
  BatchConversionResult,
  ConversionProgress,
  ConversionProgressCallback,
  IConverter,
  ConverterRegistration,
} from './conversion-types';

/**
 * 默认转换选项
 */
const DEFAULT_OPTIONS: ConversionOptions = {
  common: {
    timeout: 60000,
    overwrite: false,
  },
  html: {
    embedResources: true,
    inlineStyles: true,
    includeMetadata: false,
  },
  pdf: {
    pageSize: 'A4',
    orientation: 'portrait',
    margin: { top: 40, right: 40, bottom: 40, left: 40 },
    printBackground: true,
  },
  image: {
    quality: 90,
    deviceScaleFactor: 2,
    fullPage: true,
  },
};

/**
 * 默认批量转换选项
 */
const DEFAULT_BATCH_OPTIONS = {
  concurrency: 3,
  continueOnError: true,
  timeout: 300000,
};

/**
 * 文件格式转换 API
 */
export class ConversionAPI {
  private _connector: CoreConnector;
  private _logger: Logger;
  private _config: ConfigManager;
  private _eventBus: EventBus;
  private _converters: Map<ConversionFormat, ConverterRegistration[]> = new Map();

  constructor(
    connector: CoreConnector,
    logger: Logger,
    config: ConfigManager,
    eventBus: EventBus
  ) {
    this._connector = connector;
    this._logger = logger.createChild('ConversionAPI');
    this._config = config;
    this._eventBus = eventBus;
  }

  /**
   * 转换单个文件
   * @param request 转换请求
   * @param onProgress 进度回调
   */
  async convert(
    request: ConversionRequest,
    onProgress?: ConversionProgressCallback
  ): Promise<ConversionResult> {
    const startTime = Date.now();
    
    this._logger.debug('Starting conversion', {
      source: request.sourcePath,
      format: request.targetFormat,
    });

    // 合并选项
    const options = this._mergeOptions(request.options);

    // 发送进度：准备中
    this._reportProgress(onProgress, {
      progress: 0,
      stage: 'preparing',
      message: '准备转换...',
    });

    try {
      // 验证请求
      this._validateRequest(request);

      // 查找合适的转换器
      const converter = this._findConverter(request.targetFormat);

      if (converter) {
        // 使用注册的转换器
        return await converter.convert(
          { ...request, options },
          onProgress
        );
      }

      // 使用 Foundation file-converter
      const result = await this._convertViaFoundation(
        request,
        options,
        onProgress
      );

      const duration = Date.now() - startTime;

      // 发送进度：完成
      this._reportProgress(onProgress, {
        progress: 100,
        stage: 'completed',
        message: '转换完成',
      });

      this._logger.info('Conversion completed', {
        source: request.sourcePath,
        format: request.targetFormat,
        duration,
        success: result.success,
      });

      // 发送事件
      this._eventBus.emit('conversion:completed', {
        request,
        result,
      });

      return {
        ...result,
        duration,
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : String(error);

      this._logger.error('Conversion failed', {
        source: request.sourcePath,
        format: request.targetFormat,
        error: errorMessage,
      });

      // 发送事件
      this._eventBus.emit('conversion:failed', {
        request,
        error: errorMessage,
      });

      return {
        success: false,
        sourcePath: request.sourcePath,
        targetFormat: request.targetFormat,
        duration,
        error: errorMessage,
        errorCode: error instanceof ConversionError ? error.code : 'CONV-0001',
      };
    }
  }

  /**
   * 批量转换文件
   * @param batchRequest 批量转换请求
   * @param onProgress 进度回调
   */
  async convertBatch(
    batchRequest: BatchConversionRequest,
    onProgress?: ConversionProgressCallback
  ): Promise<BatchConversionResult> {
    const startTime = Date.now();
    const { requests, options: batchOptions } = batchRequest;
    const opts = { ...DEFAULT_BATCH_OPTIONS, ...batchOptions };

    this._logger.info('Starting batch conversion', {
      count: requests.length,
      concurrency: opts.concurrency,
    });

    const results: ConversionResult[] = [];
    let completedCount = 0;
    const totalCount = requests.length;

    // 进度报告包装器
    const reportBatchProgress = (currentFile?: string) => {
      this._reportProgress(onProgress, {
        progress: Math.round((completedCount / totalCount) * 100),
        stage: completedCount === totalCount ? 'completed' : 'converting',
        message: `正在转换 ${completedCount}/${totalCount}`,
        currentFile,
        completedCount,
        totalCount,
      });
    };

    // 初始进度
    reportBatchProgress();

    // 使用并发控制执行转换
    const queue = [...requests];
    const executing: Promise<void>[] = [];

    while (queue.length > 0 || executing.length > 0) {
      // 填充执行队列
      while (executing.length < opts.concurrency && queue.length > 0) {
        const request = queue.shift()!;
        
        const promise = this.convert(request)
          .then((result) => {
            results.push(result);
            completedCount++;
            reportBatchProgress(request.sourcePath);
          })
          .catch((error) => {
            results.push({
              success: false,
              sourcePath: request.sourcePath,
              targetFormat: request.targetFormat,
              duration: 0,
              error: error instanceof Error ? error.message : String(error),
            });
            completedCount++;
            reportBatchProgress(request.sourcePath);

            if (!opts.continueOnError) {
              throw error;
            }
          })
          .finally(() => {
            const index = executing.indexOf(promise);
            if (index > -1) {
              executing.splice(index, 1);
            }
          });

        executing.push(promise);
      }

      // 等待至少一个完成
      if (executing.length > 0) {
        await Promise.race(executing);
      }
    }

    const totalDuration = Date.now() - startTime;
    const succeeded = results.filter((r) => r.success).length;
    const failed = results.filter((r) => !r.success).length;

    this._logger.info('Batch conversion completed', {
      total: totalCount,
      succeeded,
      failed,
      duration: totalDuration,
    });

    // 发送事件
    this._eventBus.emit('conversion:batch-completed', {
      total: totalCount,
      succeeded,
      failed,
    });

    return {
      total: totalCount,
      succeeded,
      failed,
      results,
      totalDuration,
    };
  }

  /**
   * 注册转换器
   * @param converter 转换器实例
   * @param priority 优先级（默认 0）
   */
  registerConverter(converter: IConverter, priority = 0): void {
    this._logger.debug('Registering converter', {
      name: converter.name,
      formats: converter.supportedFormats,
      priority,
    });

    for (const format of converter.supportedFormats) {
      if (!this._converters.has(format)) {
        this._converters.set(format, []);
      }

      const registrations = this._converters.get(format)!;
      registrations.push({ converter, priority });

      // 按优先级排序（高优先级在前）
      registrations.sort((a, b) => b.priority - a.priority);
    }
  }

  /**
   * 注销转换器
   * @param converterName 转换器名称
   */
  unregisterConverter(converterName: string): void {
    this._logger.debug('Unregistering converter', { name: converterName });

    for (const [format, registrations] of this._converters) {
      const filtered = registrations.filter(
        (r) => r.converter.name !== converterName
      );
      if (filtered.length !== registrations.length) {
        this._converters.set(format, filtered);
      }
    }
  }

  /**
   * 获取支持的格式列表
   */
  getSupportedFormats(): ConversionFormat[] {
    const formats = new Set<ConversionFormat>(['html', 'pdf', 'png', 'jpeg', 'webp']);
    
    // 添加注册转换器支持的格式
    for (const format of this._converters.keys()) {
      formats.add(format);
    }

    return Array.from(formats);
  }

  /**
   * 检查是否支持指定格式
   */
  supportsFormat(format: ConversionFormat): boolean {
    return this.getSupportedFormats().includes(format);
  }

  /**
   * 验证转换请求
   */
  private _validateRequest(request: ConversionRequest): void {
    if (!request.sourcePath) {
      throw new ConversionError(
        ErrorCodes.CONVERSION_INVALID_REQUEST,
        '源文件路径不能为空'
      );
    }

    if (!request.targetFormat) {
      throw new ConversionError(
        ErrorCodes.CONVERSION_INVALID_REQUEST,
        '目标格式不能为空'
      );
    }

    if (!this.supportsFormat(request.targetFormat)) {
      throw new ConversionError(
        ErrorCodes.CONVERSION_UNSUPPORTED_FORMAT,
        `不支持的目标格式: ${request.targetFormat}`
      );
    }
  }

  /**
   * 查找合适的转换器
   */
  private _findConverter(format: ConversionFormat): IConverter | null {
    const registrations = this._converters.get(format);
    if (registrations && registrations.length > 0) {
      return registrations[0].converter;
    }
    return null;
  }

  /**
   * 通过 Foundation file-converter 执行转换
   */
  private async _convertViaFoundation(
    request: ConversionRequest,
    options: ConversionOptions,
    onProgress?: ConversionProgressCallback
  ): Promise<ConversionResult> {
    // 发送进度：渲染中
    this._reportProgress(onProgress, {
      progress: 20,
      stage: 'rendering',
      message: '渲染卡片内容...',
    });

    // 调用 Foundation file-converter
    const response = await this._connector.request<{
      content?: ArrayBuffer | string;
      outputPath?: string;
      fileSize?: number;
    }>({
      service: 'file-converter',
      method: 'convert',
      payload: {
        sourcePath: request.sourcePath,
        sourceType: request.sourceType,
        targetFormat: request.targetFormat,
        outputPath: request.outputPath,
        options: {
          ...options.common,
          ...options[request.targetFormat as keyof ConversionOptions],
        },
      },
      timeout: options.common?.timeout || DEFAULT_OPTIONS.common!.timeout,
    });

    // 发送进度：转换中
    this._reportProgress(onProgress, {
      progress: 80,
      stage: 'converting',
      message: '生成目标文件...',
    });

    if (!response.success) {
      throw new ConversionError(
        ErrorCodes.CONVERSION_FAILED,
        response.error || '转换失败'
      );
    }

    return {
      success: true,
      sourcePath: request.sourcePath,
      targetFormat: request.targetFormat,
      outputPath: response.data?.outputPath || request.outputPath,
      content: response.data?.content,
      fileSize: response.data?.fileSize,
      duration: 0, // 由调用者设置
    };
  }

  /**
   * 合并转换选项
   */
  private _mergeOptions(options?: ConversionOptions): ConversionOptions {
    return {
      common: { ...DEFAULT_OPTIONS.common, ...options?.common },
      html: { ...DEFAULT_OPTIONS.html, ...options?.html },
      pdf: { ...DEFAULT_OPTIONS.pdf, ...options?.pdf },
      image: { ...DEFAULT_OPTIONS.image, ...options?.image },
    };
  }

  /**
   * 报告进度
   */
  private _reportProgress(
    callback: ConversionProgressCallback | undefined,
    progress: ConversionProgress
  ): void {
    if (callback) {
      try {
        callback(progress);
      } catch (error) {
        this._logger.warn('Progress callback error', { error });
      }
    }
  }
}
```

**验收标准**:
- [ ] convert 方法正常工作
- [ ] convertBatch 方法支持并发控制
- [ ] 转换器注册/注销正常
- [ ] 进度回调正确触发
- [ ] 与 Foundation file-converter 集成成功

---

### 2.3 导出和索引

#### 任务 14.3.1: 更新模块导出
**优先级**: P0  
**描述**: 更新 `src/api/index.ts` 和 `src/index.ts`

更新 `src/api/index.ts`:
```typescript
export * from './file-api';
export * from './file-types';
export * from './card-api';
export * from './box-api';
export * from './conversion-api';
export * from './conversion-types';
```

更新 `src/index.ts` 中的 ChipsSDK 主类，添加 ConversionAPI 访问器。

**验收标准**:
- [ ] 类型和类正确导出
- [ ] ChipsSDK 主类包含 conversion 属性

---

### 2.4 单元测试

#### 任务 14.4.1: 创建 ConversionAPI 单元测试
**优先级**: P0  
**描述**: 创建 `tests/unit/api/conversion-api.test.ts`

**测试用例**:
1. convert 方法 - 卡片转 HTML
2. convert 方法 - 卡片转 PDF
3. convert 方法 - 卡片转图片（PNG/JPEG/WebP）
4. convert 方法 - 带进度回调
5. convert 方法 - 错误处理
6. convertBatch 方法 - 批量转换
7. convertBatch 方法 - 并发控制
8. convertBatch 方法 - 失败继续
9. 转换器注册/注销
10. 选项合并

**验收标准**:
- [ ] 所有测试用例通过
- [ ] 覆盖率 ≥ 85%

---

## 3. 验收标准

### 3.1 功能验收

- [ ] 卡片转 HTML 正常
- [ ] 卡片转 PDF 正常
- [ ] 卡片转图片（PNG/JPEG/WebP）正常
- [ ] 箱子转换正常
- [ ] 批量转换正常
- [ ] 进度回调正确
- [ ] 自定义转换器可注册

### 3.2 性能要求

- [ ] 单卡片转 HTML < 500ms
- [ ] 单卡片转 PNG < 2s
- [ ] 单卡片转 PDF < 3s
- [ ] 批量转换支持并发

### 3.3 代码质量

- [ ] 测试覆盖率 ≥ 85%
- [ ] 所有方法有 JSDoc 注释
- [ ] 错误处理完善

---

## 4. 注意事项

1. **依赖关系**: 依赖 Foundation file-converter 模块，确保集成正确
2. **资源处理**: 转换时需正确处理卡片内嵌资源
3. **超时控制**: PDF 和图片转换可能耗时较长，需合理设置超时
4. **内存管理**: 批量转换时注意内存使用，避免同时加载过多文件
5. **错误隔离**: 批量转换时单个失败不应影响其他任务
6. **进度精度**: 进度回调应反映真实进度，避免虚假进度

---

**状态更新日期**: 2026-02-03
