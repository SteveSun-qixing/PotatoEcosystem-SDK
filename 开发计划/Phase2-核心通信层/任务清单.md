# Phase2 - 核心通信层

**状态**: 待开始  
**预计时间**: 2-3 天  
**依赖**: Phase1

---

## 1. 阶段目标

- 实现 CoreConnector 与 Chips-Core 的 IPC 通信
- 实现标准的请求/响应处理
- 实现完善的错误处理机制
- 实现连接管理和心跳检测

---

## 2. 任务清单

### 2.1 错误处理系统

#### 任务 2.1.1: 定义错误类
**优先级**: P0  
**描述**: 创建 `src/core/errors.ts`

```typescript
/**
 * SDK 基础错误类
 */
export class ChipsError extends Error {
  constructor(
    public readonly code: string,
    message: string,
    public readonly details?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'ChipsError';
    
    // 确保原型链正确
    Object.setPrototypeOf(this, ChipsError.prototype);
  }

  toJSON(): Record<string, unknown> {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      details: this.details,
    };
  }
}

/**
 * 连接错误
 */
export class ConnectionError extends ChipsError {
  constructor(message: string, details?: Record<string, unknown>) {
    super('CONN-1001', message, details);
    this.name = 'ConnectionError';
  }
}

/**
 * 超时错误
 */
export class TimeoutError extends ChipsError {
  constructor(message: string, details?: Record<string, unknown>) {
    super('CONN-1002', message, details);
    this.name = 'TimeoutError';
  }
}

/**
 * 协议错误
 */
export class ProtocolError extends ChipsError {
  constructor(message: string, details?: Record<string, unknown>) {
    super('PROTOCOL-1001', message, details);
    this.name = 'ProtocolError';
  }
}

/**
 * 路由错误
 */
export class RouteError extends ChipsError {
  constructor(message: string, details?: Record<string, unknown>) {
    super('ROUTE-1001', message, details);
    this.name = 'RouteError';
  }
}

/**
 * 文件错误
 */
export class FileError extends ChipsError {
  constructor(code: string, message: string, details?: Record<string, unknown>) {
    super(code, message, details);
    this.name = 'FileError';
  }
}

/**
 * 验证错误
 */
export class ValidationError extends ChipsError {
  constructor(message: string, details?: Record<string, unknown>) {
    super('VAL-1001', message, details);
    this.name = 'ValidationError';
  }
}
```

**验收标准**:
- [ ] 错误类定义完整
- [ ] 错误代码规范符合标准
- [ ] 错误可序列化

---

#### 任务 2.1.2: 定义错误码常量
**优先级**: P0  
**描述**: 创建 `src/core/error-codes.ts`

```typescript
export const ErrorCodes = {
  // 连接错误 CONN-1xxx
  CONN_FAILED: 'CONN-1001',
  CONN_TIMEOUT: 'CONN-1002',
  CONN_CLOSED: 'CONN-1003',
  CONN_REFUSED: 'CONN-1004',

  // 协议错误 PROTOCOL-1xxx
  PROTOCOL_VERSION_MISMATCH: 'PROTOCOL-1001',
  PROTOCOL_INVALID_MESSAGE: 'PROTOCOL-1002',
  PROTOCOL_INVALID_RESPONSE: 'PROTOCOL-1003',

  // 路由错误 ROUTE-1xxx
  ROUTE_NOT_FOUND: 'ROUTE-1001',
  ROUTE_TIMEOUT: 'ROUTE-1002',
  ROUTE_FAILED: 'ROUTE-1003',

  // 文件错误 FILE-1xxx
  FILE_NOT_FOUND: 'FILE-1001',
  FILE_INVALID_PATH: 'FILE-1002',
  FILE_READ_FAILED: 'FILE-1003',
  FILE_WRITE_FAILED: 'FILE-1004',
  FILE_FORMAT_INVALID: 'FILE-1005',
  FILE_CORRUPTED: 'FILE-1006',

  // 验证错误 VAL-1xxx
  VAL_INVALID_INPUT: 'VAL-1001',
  VAL_REQUIRED_FIELD: 'VAL-1002',
  VAL_INVALID_TYPE: 'VAL-1003',
  VAL_INVALID_FORMAT: 'VAL-1004',

  // 资源错误 RES-1xxx
  RES_NOT_FOUND: 'RES-1001',
  RES_LOAD_FAILED: 'RES-1002',
  RES_INVALID_URI: 'RES-1003',

  // 插件错误 PLUGIN-1xxx
  PLUGIN_NOT_FOUND: 'PLUGIN-1001',
  PLUGIN_LOAD_FAILED: 'PLUGIN-1002',
  PLUGIN_INVALID: 'PLUGIN-1003',
  PLUGIN_CONFLICT: 'PLUGIN-1004',

  // 渲染错误 RENDER-1xxx
  RENDER_FAILED: 'RENDER-1001',
  RENDER_CONTAINER_INVALID: 'RENDER-1002',
  RENDER_INSTANCE_NOT_FOUND: 'RENDER-1003',

  // 主题错误 THEME-1xxx
  THEME_NOT_FOUND: 'THEME-1001',
  THEME_INVALID: 'THEME-1002',
} as const;

export type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];
```

**验收标准**:
- [ ] 错误码分类清晰
- [ ] 所有错误码有对应使用场景

---

### 2.2 通信类型定义

#### 任务 2.2.1: 定义 IPC 消息类型
**优先级**: P0  
**描述**: 创建 `src/core/types.ts`

```typescript
import { ProtocolVersion, Status, Timestamp } from '../types/base';

/**
 * IPC 消息类型
 */
export type MessageType =
  | 'Route'
  | 'Publish'
  | 'Subscribe'
  | 'Unsubscribe'
  | 'ConfigGet'
  | 'ConfigSet'
  | 'Status'
  | 'Heartbeat';

/**
 * IPC 请求消息
 */
export interface IpcRequest {
  id: string;
  message_type: MessageType;
  payload: RoutePayload | PublishPayload | SubscribePayload | ConfigPayload;
  timestamp: Timestamp;
  protocol_version?: ProtocolVersion;
}

/**
 * 路由请求载荷
 */
export interface RoutePayload {
  sender: string;
  action: string;
  params: Record<string, unknown>;
  timeout_ms?: number;
}

/**
 * 发布事件载荷
 */
export interface PublishPayload {
  event_type: string;
  sender: string;
  data: Record<string, unknown>;
}

/**
 * 订阅事件载荷
 */
export interface SubscribePayload {
  subscriber_id: string;
  event_type: string;
  filter?: Record<string, unknown>;
}

/**
 * 配置操作载荷
 */
export interface ConfigPayload {
  key: string;
  value?: unknown;
}

/**
 * IPC 响应消息
 */
export interface IpcResponse {
  request_id: string;
  success: boolean;
  data?: unknown;
  error?: string;
  timestamp: Timestamp;
}

/**
 * 事件推送消息
 */
export interface EventMessage {
  type: 'event';
  event_type: string;
  sender: string;
  data: Record<string, unknown>;
  timestamp: Timestamp;
}

/**
 * 请求参数
 */
export interface RequestParams {
  service: string;
  method: string;
  payload: Record<string, unknown>;
  timeout?: number;
}

/**
 * 响应数据
 */
export interface ResponseData<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
}

/**
 * 连接选项
 */
export interface ConnectorOptions {
  url?: string;
  timeout?: number;
  reconnect?: boolean;
  reconnectDelay?: number;
  maxReconnectAttempts?: number;
  heartbeatInterval?: number;
}
```

**验收标准**:
- [ ] 类型定义完整
- [ ] 符合 Chips-Core 的 IPC 协议规范

---

### 2.3 CoreConnector 实现

#### 任务 2.3.1: 实现 CoreConnector 接口
**优先级**: P0  
**描述**: 创建 `src/core/connector.ts`

```typescript
import {
  ConnectorOptions,
  IpcRequest,
  IpcResponse,
  MessageType,
  RequestParams,
  ResponseData,
  RoutePayload,
} from './types';
import { ConnectionError, TimeoutError, ProtocolError } from './errors';
import { generateUuid } from '../utils/id';
import { withTimeout } from '../utils/async';

/**
 * Core 连接器配置默认值
 */
const DEFAULT_OPTIONS: Required<ConnectorOptions> = {
  url: 'ws://127.0.0.1:9527',
  timeout: 30000,
  reconnect: true,
  reconnectDelay: 1000,
  maxReconnectAttempts: 5,
  heartbeatInterval: 30000,
};

/**
 * Core 连接器
 * 负责与 Chips-Core 的 IPC 通信
 */
export class CoreConnector {
  private _options: Required<ConnectorOptions>;
  private _socket: WebSocket | null = null;
  private _pendingRequests = new Map<
    string,
    {
      resolve: (value: ResponseData) => void;
      reject: (error: Error) => void;
      timeout: NodeJS.Timeout;
    }
  >();
  private _eventHandlers = new Map<string, Set<(data: unknown) => void>>();
  private _connected = false;
  private _reconnectAttempts = 0;
  private _heartbeatTimer: NodeJS.Timeout | null = null;
  private _clientId: string;

  constructor(options?: ConnectorOptions) {
    this._options = { ...DEFAULT_OPTIONS, ...options };
    this._clientId = `sdk-${generateUuid().slice(0, 8)}`;
  }

  /**
   * 连接到 Core
   */
  async connect(): Promise<void> {
    if (this._connected) {
      return;
    }

    return new Promise((resolve, reject) => {
      try {
        this._socket = new WebSocket(this._options.url);

        this._socket.onopen = () => {
          this._connected = true;
          this._reconnectAttempts = 0;
          this._startHeartbeat();
          resolve();
        };

        this._socket.onmessage = (event) => {
          this._handleMessage(event.data as string);
        };

        this._socket.onerror = (event) => {
          reject(new ConnectionError('Connection failed', { event }));
        };

        this._socket.onclose = () => {
          this._connected = false;
          this._stopHeartbeat();
          this._handleDisconnect();
        };
      } catch (error) {
        reject(
          new ConnectionError('Failed to create WebSocket', {
            error: String(error),
          })
        );
      }
    });
  }

  /**
   * 断开连接
   */
  disconnect(): void {
    this._stopHeartbeat();
    
    if (this._socket) {
      this._socket.close();
      this._socket = null;
    }
    
    this._connected = false;
    
    // 清理所有待处理请求
    for (const [id, pending] of this._pendingRequests) {
      clearTimeout(pending.timeout);
      pending.reject(new ConnectionError('Connection closed'));
    }
    this._pendingRequests.clear();
  }

  /**
   * 发送请求
   */
  async request<T = unknown>(params: RequestParams): Promise<ResponseData<T>> {
    if (!this._connected || !this._socket) {
      throw new ConnectionError('Not connected to Core');
    }

    const id = generateUuid();
    const request: IpcRequest = {
      id,
      message_type: 'Route',
      payload: {
        sender: this._clientId,
        action: `${params.service}.${params.method}`,
        params: params.payload,
        timeout_ms: params.timeout || this._options.timeout,
      } as RoutePayload,
      timestamp: new Date().toISOString(),
    };

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        this._pendingRequests.delete(id);
        reject(
          new TimeoutError('Request timed out', {
            service: params.service,
            method: params.method,
          })
        );
      }, params.timeout || this._options.timeout);

      this._pendingRequests.set(id, {
        resolve: resolve as (value: ResponseData) => void,
        reject,
        timeout,
      });

      try {
        this._socket!.send(JSON.stringify(request) + '\n');
      } catch (error) {
        this._pendingRequests.delete(id);
        clearTimeout(timeout);
        reject(
          new ConnectionError('Failed to send request', {
            error: String(error),
          })
        );
      }
    });
  }

  /**
   * 订阅事件
   */
  on(eventType: string, handler: (data: unknown) => void): void {
    if (!this._eventHandlers.has(eventType)) {
      this._eventHandlers.set(eventType, new Set());
    }
    this._eventHandlers.get(eventType)!.add(handler);
  }

  /**
   * 取消订阅事件
   */
  off(eventType: string, handler?: (data: unknown) => void): void {
    if (!handler) {
      this._eventHandlers.delete(eventType);
    } else {
      this._eventHandlers.get(eventType)?.delete(handler);
    }
  }

  /**
   * 检查是否已连接
   */
  get isConnected(): boolean {
    return this._connected;
  }

  /**
   * 获取客户端 ID
   */
  get clientId(): string {
    return this._clientId;
  }

  /**
   * 处理收到的消息
   */
  private _handleMessage(data: string): void {
    try {
      const message = JSON.parse(data) as IpcResponse | { type: string };

      // 检查是否是事件推送
      if ('type' in message && message.type === 'event') {
        this._handleEvent(message as unknown as { event_type: string; data: unknown });
        return;
      }

      // 处理响应
      const response = message as IpcResponse;
      const pending = this._pendingRequests.get(response.request_id);
      
      if (pending) {
        clearTimeout(pending.timeout);
        this._pendingRequests.delete(response.request_id);
        
        pending.resolve({
          success: response.success,
          data: response.data,
          error: response.error,
        });
      }
    } catch (error) {
      console.error('Failed to parse message:', error);
    }
  }

  /**
   * 处理事件推送
   */
  private _handleEvent(event: { event_type: string; data: unknown }): void {
    const handlers = this._eventHandlers.get(event.event_type);
    if (handlers) {
      for (const handler of handlers) {
        try {
          handler(event.data);
        } catch (error) {
          console.error('Event handler error:', error);
        }
      }
    }

    // 通配符处理
    const wildcardHandlers = this._eventHandlers.get('*');
    if (wildcardHandlers) {
      for (const handler of wildcardHandlers) {
        try {
          handler(event);
        } catch (error) {
          console.error('Wildcard event handler error:', error);
        }
      }
    }
  }

  /**
   * 处理断开连接
   */
  private _handleDisconnect(): void {
    if (
      this._options.reconnect &&
      this._reconnectAttempts < this._options.maxReconnectAttempts
    ) {
      this._reconnectAttempts++;
      setTimeout(() => {
        this.connect().catch(console.error);
      }, this._options.reconnectDelay * this._reconnectAttempts);
    }
  }

  /**
   * 启动心跳
   */
  private _startHeartbeat(): void {
    this._heartbeatTimer = setInterval(() => {
      if (this._connected && this._socket) {
        const heartbeat: IpcRequest = {
          id: generateUuid(),
          message_type: 'Heartbeat',
          payload: { sender: this._clientId, action: '', params: {} },
          timestamp: new Date().toISOString(),
        };
        this._socket.send(JSON.stringify(heartbeat) + '\n');
      }
    }, this._options.heartbeatInterval);
  }

  /**
   * 停止心跳
   */
  private _stopHeartbeat(): void {
    if (this._heartbeatTimer) {
      clearInterval(this._heartbeatTimer);
      this._heartbeatTimer = null;
    }
  }
}
```

**验收标准**:
- [ ] 连接/断开功能正常
- [ ] 请求/响应处理正确
- [ ] 超时处理有效
- [ ] 心跳检测正常
- [ ] 自动重连功能可用

---

#### 任务 2.3.2: 创建 CoreConnector 单元测试
**优先级**: P0  
**描述**: 创建 `tests/unit/core/connector.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { CoreConnector } from '../../../src/core/connector';
import { ConnectionError, TimeoutError } from '../../../src/core/errors';

// Mock WebSocket
class MockWebSocket {
  onopen: (() => void) | null = null;
  onmessage: ((event: { data: string }) => void) | null = null;
  onerror: ((event: any) => void) | null = null;
  onclose: (() => void) | null = null;
  
  send = vi.fn();
  close = vi.fn();

  triggerOpen(): void {
    this.onopen?.();
  }

  triggerMessage(data: string): void {
    this.onmessage?.({ data });
  }

  triggerError(error: any): void {
    this.onerror?.(error);
  }

  triggerClose(): void {
    this.onclose?.();
  }
}

describe('CoreConnector', () => {
  let connector: CoreConnector;
  let mockWs: MockWebSocket;

  beforeEach(() => {
    mockWs = new MockWebSocket();
    vi.stubGlobal('WebSocket', vi.fn(() => mockWs));
    connector = new CoreConnector({ reconnect: false });
  });

  afterEach(() => {
    connector.disconnect();
    vi.unstubAllGlobals();
  });

  describe('connect', () => {
    it('should connect successfully', async () => {
      const connectPromise = connector.connect();
      mockWs.triggerOpen();
      
      await expect(connectPromise).resolves.toBeUndefined();
      expect(connector.isConnected).toBe(true);
    });

    it('should reject on connection error', async () => {
      const connectPromise = connector.connect();
      mockWs.triggerError({ message: 'Connection failed' });
      
      await expect(connectPromise).rejects.toThrow(ConnectionError);
    });
  });

  describe('request', () => {
    beforeEach(async () => {
      const connectPromise = connector.connect();
      mockWs.triggerOpen();
      await connectPromise;
    });

    it('should send request and receive response', async () => {
      const requestPromise = connector.request({
        service: 'test',
        method: 'echo',
        payload: { message: 'hello' },
      });

      // 模拟响应
      const sentMessage = JSON.parse(mockWs.send.mock.calls[0][0].replace('\n', ''));
      mockWs.triggerMessage(
        JSON.stringify({
          request_id: sentMessage.id,
          success: true,
          data: { result: 'hello' },
          timestamp: new Date().toISOString(),
        })
      );

      const response = await requestPromise;
      expect(response.success).toBe(true);
      expect(response.data).toEqual({ result: 'hello' });
    });

    it('should timeout if no response', async () => {
      const requestPromise = connector.request({
        service: 'test',
        method: 'slow',
        payload: {},
        timeout: 100,
      });

      await expect(requestPromise).rejects.toThrow(TimeoutError);
    });

    it('should throw if not connected', () => {
      connector.disconnect();
      
      expect(() =>
        connector.request({
          service: 'test',
          method: 'echo',
          payload: {},
        })
      ).rejects.toThrow(ConnectionError);
    });
  });

  describe('events', () => {
    it('should handle event subscription', () => {
      const handler = vi.fn();
      connector.on('test:event', handler);
      
      // 模拟事件
      connector['_handleEvent']({
        event_type: 'test:event',
        data: { value: 123 },
      });
      
      expect(handler).toHaveBeenCalledWith({ value: 123 });
    });

    it('should handle event unsubscription', () => {
      const handler = vi.fn();
      connector.on('test:event', handler);
      connector.off('test:event', handler);
      
      connector['_handleEvent']({
        event_type: 'test:event',
        data: { value: 123 },
      });
      
      expect(handler).not.toHaveBeenCalled();
    });
  });
});
```

**验收标准**:
- [ ] 连接测试通过
- [ ] 请求测试通过
- [ ] 事件测试通过
- [ ] 覆盖率 ≥ 90%

---

### 2.4 索引文件

#### 任务 2.4.1: 创建 core 模块导出
**优先级**: P0  
**描述**: 创建 `src/core/index.ts`

```typescript
export { CoreConnector } from './connector';
export type {
  ConnectorOptions,
  RequestParams,
  ResponseData,
  IpcRequest,
  IpcResponse,
  MessageType,
  RoutePayload,
  PublishPayload,
  SubscribePayload,
  ConfigPayload,
  EventMessage,
} from './types';
export {
  ChipsError,
  ConnectionError,
  TimeoutError,
  ProtocolError,
  RouteError,
  FileError,
  ValidationError,
} from './errors';
export { ErrorCodes } from './error-codes';
export type { ErrorCode } from './error-codes';
```

**验收标准**:
- [ ] 所有导出正确
- [ ] 类型导出完整

---

## 3. 验收标准

### 3.1 功能验收

- [ ] CoreConnector 可连接到模拟的 Core 服务
- [ ] 请求/响应处理正确
- [ ] 超时机制有效
- [ ] 心跳检测正常
- [ ] 自动重连功能可用
- [ ] 事件订阅/取消订阅正常

### 3.2 代码质量

- [ ] 所有方法有 JSDoc 注释
- [ ] 错误处理完善
- [ ] 类型定义完整
- [ ] 测试覆盖率 ≥ 90%

### 3.3 性能要求

- [ ] 连接建立时间 < 100ms（本地）
- [ ] 请求响应处理延迟 < 10ms
- [ ] 内存占用稳定，无泄漏

---

## 4. 注意事项

1. **协议兼容**: 必须严格遵循 Chips-Core 的 IPC 协议规范
2. **超时处理**: 所有请求必须有超时机制
3. **错误处理**: 使用标准错误码
4. **线程安全**: 注意并发请求的处理
5. **资源释放**: 断开连接时清理所有资源

---

**状态更新日期**: 2026-02-01
