# 架构设计

## 1. 架构概述

Chips SDK 采用分层、模块化的架构设计,基于薯片内核构建,通过清晰的抽象层次和接口定义,为第三方开发者提供简洁易用的 API。

### 1.1 设计目标

1. **简单易用**：提供高层 API,隐藏复杂实现
2. **模块化**：功能模块独立,可按需引入
3. **可扩展**：支持插件和自定义扩展
4. **跨平台**：统一 API,多平台适配
5. **高性能**：优化的实现,最小化开销

### 1.2 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                  应用层 (Application Layer)              │
│              第三方开发者使用 SDK 开发应用                │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│                   API 层 (API Layer)                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐│
│  │  File    │  │ Renderer │  │  Editor  │  │  Theme   ││
│  │   API    │  │   API    │  │   API    │  │   API    ││
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘│
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│                核心层 (Core Layer)                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐│
│  │  Parser  │  │ Renderer │  │  Editor  │  │  Plugin  ││
│  │  Engine  │  │  Engine  │  │  Engine  │  │  System  ││
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘│
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐│
│  │  Cache   │  │Resource  │  │  Event   │  │  Utils   ││
│  │  Manager │  │ Manager  │  │   Bus    │  │          ││
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘│
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│              薯片内核层 (Chips Core Layer)               │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐│
│  │  File    │  │  Plugin  │  │  Theme   │  │ Resource ││
│  │  System  │  │  System  │  │  System  │  │ Manager  ││
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘│
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│            平台适配层 (Platform Adapter Layer)           │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐│
│  │   Web    │  │  Node.js │  │ Electron │  │  Mobile  ││
│  │(Browser) │  │          │  │          │  │(iOS/And) ││
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘│
└─────────────────────────────────────────────────────────┘
```

## 2. 分层架构详解

### 2.1 平台适配层

**职责**：
- 封装不同平台的差异
- 提供统一的底层 API
- 处理平台特定的功能

**主要组件**：

#### 2.1.1 Web 适配器
```typescript
// platform/web/WebAdapter.ts
export class WebAdapter implements IPlatformAdapter {
  async readFile(path: string): Promise<ArrayBuffer> {
    const response = await fetch(path);
    return response.arrayBuffer();
  }
  
  async writeFile(path: string, data: ArrayBuffer): Promise<void> {
    // 使用 IndexedDB 或 localStorage
    await idb.put('files', { path, data });
  }
  
  getFileSystem(): IFileSystem {
    return new WebFileSystem();
  }
}
```

#### 2.1.2 Node.js 适配器
```typescript
// platform/node/NodeAdapter.ts
import * as fs from 'fs/promises';

export class NodeAdapter implements IPlatformAdapter {
  async readFile(path: string): Promise<ArrayBuffer> {
    const buffer = await fs.readFile(path);
    return buffer.buffer;
  }
  
  async writeFile(path: string, data: ArrayBuffer): Promise<void> {
    await fs.writeFile(path, Buffer.from(data));
  }
  
  getFileSystem(): IFileSystem {
    return new NodeFileSystem();
  }
}
```

### 2.2 薯片内核层

**职责**：
- 提供核心功能和服务
- 管理插件生命周期
- 处理文件和资源
- 执行生态标准

**SDK 如何使用内核**：
```typescript
// core/ChipsCore.ts
export class ChipsCore {
  private static instance: ChipsCore;
  
  private fileSystem: FileSystemService;
  private pluginManager: PluginManager;
  private themeManager: ThemeManager;
  private resourceManager: ResourceManager;
  
  static getInstance(): ChipsCore {
    if (!ChipsCore.instance) {
      ChipsCore.instance = new ChipsCore();
    }
    return ChipsCore.instance;
  }
  
  async initialize(adapter: IPlatformAdapter): Promise<void> {
    this.fileSystem = new FileSystemService(adapter);
    this.pluginManager = new PluginManager();
    this.themeManager = new ThemeManager();
    this.resourceManager = new ResourceManager();
    
    await this.pluginManager.initialize();
    await this.themeManager.initialize();
  }
}
```

### 2.3 核心层 (SDK Core)

**职责**：
- 实现 SDK 的核心功能
- 封装内核的复杂性
- 提供模块化的服务

**主要模块**：

#### 2.3.1 解析引擎
```typescript
// core/parser/ParserEngine.ts
export class ParserEngine {
  parseCard(data: ArrayBuffer): Card {
    // 解析卡片二进制数据
    const json = this.bufferToJSON(data);
    return this.validateAndNormalize(json);
  }
  
  serializeCard(card: Card): ArrayBuffer {
    // 序列化卡片为二进制
    const json = JSON.stringify(card);
    return this.jsonToBuffer(json);
  }
  
  private validateAndNormalize(data: any): Card {
    // 验证和标准化卡片数据
    this.validator.validate(data);
    return this.normalizer.normalize(data);
  }
}
```

#### 2.3.2 渲染引擎
```typescript
// core/renderer/RendererEngine.ts
export class RendererEngine {
  private rendererFactory: RendererFactory;
  private themeApplier: ThemeApplier;
  
  async render(
    card: Card,
    container: HTMLElement,
    options: RenderOptions
  ): Promise<RenderResult> {
    // 获取渲染器
    const renderer = this.rendererFactory.getRenderer(card.type);
    
    // 渲染卡片
    const result = await renderer.render(card, container, options);
    
    // 应用主题
    if (options.theme) {
      this.themeApplier.apply(options.theme, result.element);
    }
    
    return result;
  }
}
```

#### 2.3.3 编辑引擎
```typescript
// core/editor/EditorEngine.ts
export class EditorEngine {
  private document: EditorDocument;
  private selection: Selection;
  private history: History;
  
  createEditor(
    container: HTMLElement,
    options: EditorOptions
  ): IEditor {
    return new Editor(container, options, this);
  }
  
  insertContent(content: Content): void {
    const position = this.selection.getCursor();
    this.document.insert(position, content);
    this.history.push({ type: 'insert', position, content });
  }
  
  undo(): void {
    const operation = this.history.undo();
    this.applyOperation(operation);
  }
}
```

#### 2.3.4 插件系统
```typescript
// core/plugin/PluginSystem.ts
export class PluginSystem {
  private plugins: Map<string, Plugin> = new Map();
  
  use(plugin: Plugin | Plugin[]): void {
    const plugins = Array.isArray(plugin) ? plugin : [plugin];
    
    plugins.forEach(p => {
      p.install(this.getPluginContext());
      this.plugins.set(p.id, p);
    });
  }
  
  unuse(pluginId: string): void {
    const plugin = this.plugins.get(pluginId);
    if (plugin) {
      plugin.uninstall();
      this.plugins.delete(pluginId);
    }
  }
  
  getPluginContext(): PluginContext {
    return {
      registerCardType: (type, renderer) => { /* ... */ },
      registerCommand: (name, handler) => { /* ... */ },
      on: (event, handler) => { /* ... */ }
    };
  }
}
```

### 2.4 API 层

**职责**：
- 提供开发者友好的 API
- 简化常见操作
- 处理参数验证和错误

**API 设计示例**：

#### 2.4.1 File API
```typescript
// api/FileAPI.ts
export class FileAPI {
  constructor(
    private core: ChipsCore,
    private parser: ParserEngine
  ) {}
  
  async loadCard(
    path: string | File,
    options?: LoadOptions
  ): Promise<Card> {
    // 参数归一化
    const normalizedPath = this.normalizePath(path);
    
    // 缓存检查
    if (options?.cache !== false) {
      const cached = await this.cache.get(normalizedPath);
      if (cached) return cached;
    }
    
    // 读取文件
    const data = await this.core.fileSystem.readFile(normalizedPath);
    
    // 解析卡片
    const card = this.parser.parseCard(data);
    
    // 验证
    if (options?.validate !== false) {
      this.validator.validate(card);
    }
    
    // 缓存
    if (options?.cache !== false) {
      await this.cache.set(normalizedPath, card);
    }
    
    return card;
  }
  
  async saveCard(
    card: Card,
    path: string,
    options?: SaveOptions
  ): Promise<void> {
    // 序列化
    const data = this.parser.serializeCard(card);
    
    // 写入文件
    await this.core.fileSystem.writeFile(path, data);
    
    // 更新缓存
    await this.cache.set(path, card);
  }
}
```

#### 2.4.2 Renderer API
```typescript
// api/RendererAPI.ts
export class RendererAPI {
  constructor(
    private engine: RendererEngine,
    private themeManager: ThemeManager
  ) {}
  
  async renderCard(
    card: Card | string,
    container: string | HTMLElement,
    options?: RenderOptions
  ): Promise<void> {
    // 加载卡片（如果是路径）
    const cardData = typeof card === 'string'
      ? await this.loadCard(card)
      : card;
    
    // 获取容器元素
    const containerElement = typeof container === 'string'
      ? document.querySelector(container)
      : container;
    
    if (!containerElement) {
      throw new Error(`Container not found: ${container}`);
    }
    
    // 应用默认选项
    const finalOptions = {
      theme: this.themeManager.getCurrentTheme(),
      readOnly: false,
      interactive: true,
      ...options
    };
    
    // 渲染
    await this.engine.render(cardData, containerElement, finalOptions);
  }
}
```

## 3. 模块划分

### 3.1 核心模块

```
sdk/
├── core/                      # SDK 核心
│   ├── parser/               # 解析引擎
│   │   ├── ParserEngine.ts
│   │   ├── Validator.ts
│   │   └── Normalizer.ts
│   │
│   ├── renderer/             # 渲染引擎
│   │   ├── RendererEngine.ts
│   │   ├── RendererFactory.ts
│   │   ├── CardRenderer.ts
│   │   └── ThemeApplier.ts
│   │
│   ├── editor/               # 编辑引擎
│   │   ├── EditorEngine.ts
│   │   ├── Editor.ts
│   │   ├── EditorDocument.ts
│   │   ├── Selection.ts
│   │   └── History.ts
│   │
│   ├── plugin/               # 插件系统
│   │   ├── PluginSystem.ts
│   │   ├── PluginManager.ts
│   │   └── PluginLoader.ts
│   │
│   ├── cache/                # 缓存管理
│   │   ├── CacheManager.ts
│   │   └── CacheStrategy.ts
│   │
│   ├── resource/             # 资源管理
│   │   ├── ResourceManager.ts
│   │   └── ResourceLoader.ts
│   │
│   └── event/                # 事件系统
│       ├── EventBus.ts
│       └── EventEmitter.ts
```

### 3.2 API 模块

```
sdk/
├── api/                       # 公开 API
│   ├── ChipsSDK.ts           # SDK 主类
│   ├── FileAPI.ts            # 文件 API
│   ├── RendererAPI.ts        # 渲染 API
│   ├── EditorAPI.ts          # 编辑 API
│   ├── ThemeAPI.ts           # 主题 API
│   └── PluginAPI.ts          # 插件 API
```

### 3.3 工具模块

```
sdk/
├── utils/                     # 工具函数
│   ├── file.ts               # 文件工具
│   ├── dom.ts                # DOM 工具
│   ├── format.ts             # 格式化工具
│   ├── validation.ts         # 验证工具
│   └── async.ts              # 异步工具
├── types/                     # 类型定义
│   ├── card.ts
│   ├── plugin.ts
│   ├── theme.ts
│   └── index.ts
└── constants/                 # 常量定义
    ├── events.ts
    ├── errors.ts
    └── defaults.ts
```

### 3.4 平台模块

```
sdk/
├── platform/                  # 平台适配
│   ├── IPlatformAdapter.ts   # 平台接口
│   ├── web/                  # Web 平台
│   │   ├── WebAdapter.ts
│   │   └── WebFileSystem.ts
│   ├── node/                 # Node.js 平台
│   │   ├── NodeAdapter.ts
│   │   └── NodeFileSystem.ts
│   ├── electron/             # Electron 平台
│   │   └── ElectronAdapter.ts
│   └── mobile/               # 移动平台
│       ├── iOSAdapter.swift
│       └── AndroidAdapter.kt
```

## 4. 数据流

### 4.1 文件加载流程

```
用户调用 chips.loadCard('card.card')
    ↓
FileAPI.loadCard()
    ↓
检查缓存
    ↓ (缓存未命中)
ChipsCore.fileSystem.readFile()
    ↓
PlatformAdapter.readFile()
    ↓
返回 ArrayBuffer
    ↓
ParserEngine.parseCard()
    ↓
Validator.validate()
    ↓
Normalizer.normalize()
    ↓
返回 Card 对象
    ↓
CacheManager.set() (缓存结果)
    ↓
返回给用户
```

### 4.2 卡片渲染流程

```
用户调用 chips.renderCard(card, container)
    ↓
RendererAPI.renderCard()
    ↓
归一化参数 (card, container, options)
    ↓
RendererEngine.render()
    ↓
RendererFactory.getRenderer(card.type)
    ↓
CardRenderer.render()
    ↓
创建 DOM 元素
    ↓
渲染内容
    ↓
ThemeApplier.apply()
    ↓
挂载到容器
    ↓
触发 'render' 事件
    ↓
返回 RenderResult
```

### 4.3 编辑流程

```
用户在编辑器中输入
    ↓
Editor.handleInput()
    ↓
EditorDocument.insert()
    ↓
更新文档模型
    ↓
Selection.update()
    ↓
History.push()
    ↓
触发 'change' 事件
    ↓
重新渲染变更部分
    ↓
更新视图
```

## 5. 依赖管理

### 5.1 内部依赖

```typescript
// SDK 内部依赖通过依赖注入管理
export class ChipsSDK {
  private core: ChipsCore;
  private fileAPI: FileAPI;
  private rendererAPI: RendererAPI;
  private editorAPI: EditorAPI;
  
  constructor(options?: SDKOptions) {
    // 创建核心实例
    this.core = ChipsCore.getInstance();
    
    // 初始化平台适配器
    const adapter = this.createPlatformAdapter();
    await this.core.initialize(adapter);
    
    // 创建 API 实例
    this.fileAPI = new FileAPI(this.core, new ParserEngine());
    this.rendererAPI = new RendererAPI(
      new RendererEngine(),
      this.core.themeManager
    );
    this.editorAPI = new EditorAPI(new EditorEngine());
  }
}
```

### 5.2 外部依赖

```json
// package.json
{
  "dependencies": {
    // 核心依赖（必需）
    "@chips/core": "^1.0.0",
    
    // 运行时依赖
    "eventemitter3": "^5.0.0",
    
    // 可选依赖（按需加载）
    "video.js": "^8.0.0",
    "prismjs": "^1.29.0",
    "katex": "^0.16.0"
  },
  "peerDependencies": {
    // 由用户提供
    "react": "^18.0.0"  // 如果使用 React 组件
  }
}
```

## 6. 性能优化

### 6.1 懒加载

```typescript
// 按需加载渲染器
class RendererFactory {
  private renderers: Map<CardType, Promise<ICardRenderer>> = new Map();
  
  async getRenderer(type: CardType): Promise<ICardRenderer> {
    if (!this.renderers.has(type)) {
      // 懒加载渲染器
      const promise = this.loadRenderer(type);
      this.renderers.set(type, promise);
    }
    
    return this.renderers.get(type)!;
  }
  
  private async loadRenderer(type: CardType): Promise<ICardRenderer> {
    switch (type) {
      case 'video':
        return (await import('./renderers/VideoRenderer')).VideoRenderer;
      case 'audio':
        return (await import('./renderers/AudioRenderer')).AudioRenderer;
      // ...
    }
  }
}
```

### 6.2 缓存策略

```typescript
// 多级缓存
class CacheManager {
  private memoryCache: Map<string, any> = new Map();
  private diskCache: IDBCache;
  
  async get(key: string): Promise<any> {
    // L1: 内存缓存
    if (this.memoryCache.has(key)) {
      return this.memoryCache.get(key);
    }
    
    // L2: IndexedDB 缓存
    const diskCached = await this.diskCache.get(key);
    if (diskCached) {
      this.memoryCache.set(key, diskCached);
      return diskCached;
    }
    
    return null;
  }
  
  async set(key: string, value: any): Promise<void> {
    // 同时写入两级缓存
    this.memoryCache.set(key, value);
    await this.diskCache.set(key, value);
  }
}
```

### 6.3 虚拟滚动

```typescript
// 渲染大量卡片时使用虚拟滚动
class VirtualScroller {
  private viewport: HTMLElement;
  private items: Card[];
  private itemHeight: number;
  private visibleRange: [number, number] = [0, 0];
  
  render(): void {
    const scrollTop = this.viewport.scrollTop;
    const viewportHeight = this.viewport.clientHeight;
    
    // 计算可见范围
    const startIndex = Math.floor(scrollTop / this.itemHeight);
    const endIndex = Math.ceil((scrollTop + viewportHeight) / this.itemHeight);
    
    // 只渲染可见项
    this.renderRange(startIndex, endIndex);
  }
}
```

## 7. 错误处理

### 7.1 错误边界

```typescript
// 全局错误处理
export class ChipsSDK {
  private errorHandler: ErrorHandler;
  
  constructor() {
    this.errorHandler = new ErrorHandler();
    
    // 捕获未处理的错误
    this.setupGlobalErrorHandler();
  }
  
  private setupGlobalErrorHandler(): void {
    window.addEventListener('error', (event) => {
      this.errorHandler.handle(event.error);
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      this.errorHandler.handle(event.reason);
    });
  }
}

class ErrorHandler {
  handle(error: Error): void {
    // 记录错误
    console.error('[Chips SDK]', error);
    
    // 上报错误（如果配置了）
    if (this.reportingEnabled) {
      this.reportError(error);
    }
    
    // 触发错误事件
    this.eventBus.emit('error', error);
  }
}
```

## 8. 测试架构

### 8.1 单元测试

```typescript
// 测试工具和 Mock
export class TestUtils {
  static createMockCard(type: CardType): Card {
    return {
      id: 'test-' + Date.now(),
      type,
      version: '1.0.0',
      metadata: {},
      content: {}
    };
  }
  
  static createMockContainer(): HTMLElement {
    return document.createElement('div');
  }
}

// 测试示例
describe('FileAPI', () => {
  let fileAPI: FileAPI;
  let mockCore: jest.Mocked<ChipsCore>;
  
  beforeEach(() => {
    mockCore = createMockCore();
    fileAPI = new FileAPI(mockCore, new ParserEngine());
  });
  
  it('should load card', async () => {
    const card = await fileAPI.loadCard('test.card');
    expect(card.type).toBe('richtext');
  });
});
```

## 9. 总结

Chips SDK 的架构设计体现了以下特点：

**架构优势**：
1. ✅ **清晰分层**：职责明确,易于理解和维护
2. ✅ **模块化**：功能独立,可按需引入
3. ✅ **可扩展**：插件系统支持功能扩展
4. ✅ **跨平台**：统一抽象,多平台适配
5. ✅ **高性能**：优化策略,最小化开销
6. ✅ **易测试**：依赖注入,便于单元测试

通过合理的架构设计,Chips SDK 能够为开发者提供简单易用且功能强大的 API,同时保持代码的可维护性和可扩展性。
